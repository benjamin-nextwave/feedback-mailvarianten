---
phase: 01-foundation-design-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/supabase/server.ts
  - src/lib/supabase/client.ts
  - src/lib/utils.ts
  - src/types/database.types.ts
  - supabase/migrations/20260210000000_create_initial_schema.sql
  - .env.example
  - .env.local
  - package.json
  - tsconfig.json
  - next.config.ts
  - tailwind.config.ts
  - src/app/layout.tsx
  - src/app/page.tsx
  - src/app/globals.css
autonomous: true
user_setup:
  - service: supabase
    why: "Database and authentication backend"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon/public key"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> service_role key (keep secret)"
    dashboard_config:
      - task: "Create a new Supabase project (if not already created)"
        location: "Supabase Dashboard -> New Project"
      - task: "Run the migration SQL in the SQL Editor to create tables, RLS policies, and indexes"
        location: "Supabase Dashboard -> SQL Editor -> New query -> Paste migration SQL -> Run"

must_haves:
  truths:
    - "Next.js 15 app builds and runs with `npm run dev`"
    - "Supabase server and client utilities exist and are importable"
    - "Database migration SQL creates forms, email_variants, and feedback_responses tables"
    - "RLS policies grant authenticated users full access and anonymous users read+insert access"
    - "Environment variables are documented in .env.example"
    - "TypeScript types for database tables are defined and importable"
  artifacts:
    - path: "src/lib/supabase/server.ts"
      provides: "Server-side Supabase client creator using @supabase/ssr"
      exports: ["createClient"]
    - path: "src/lib/supabase/client.ts"
      provides: "Browser-side Supabase client creator using @supabase/ssr"
      exports: ["createClient"]
    - path: "src/types/database.types.ts"
      provides: "TypeScript types for forms, email_variants, feedback_responses tables"
      contains: "Database"
    - path: "supabase/migrations/20260210000000_create_initial_schema.sql"
      provides: "Complete database schema with tables, RLS policies, and indexes"
      contains: "CREATE TABLE"
    - path: ".env.example"
      provides: "Environment variable template"
      contains: "NEXT_PUBLIC_SUPABASE_URL"
  key_links:
    - from: "src/lib/supabase/server.ts"
      to: "@supabase/ssr"
      via: "createServerClient import"
      pattern: "createServerClient"
    - from: "src/lib/supabase/client.ts"
      to: "@supabase/ssr"
      via: "createBrowserClient import"
      pattern: "createBrowserClient"
    - from: "src/types/database.types.ts"
      to: "supabase/migrations/20260210000000_create_initial_schema.sql"
      via: "types mirror the schema tables"
      pattern: "forms.*email_variants.*feedback_responses"
---

<objective>
Scaffold the Next.js 15 project, install all dependencies, configure Supabase client utilities, create the database migration SQL with full schema and RLS policies, and set up environment variable documentation.

Purpose: Establish the foundational infrastructure that all subsequent phases build upon -- the running application, database schema, security policies, and type system.
Output: A buildable Next.js 15 app with Supabase clients, complete migration SQL, TypeScript database types, and environment configuration.
</objective>

<execution_context>
@C:\Users\bstei\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\bstei\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-design-system/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Next.js 15 project with Supabase client setup and environment configuration</name>
  <files>
    package.json
    tsconfig.json
    next.config.ts
    src/app/layout.tsx
    src/app/page.tsx
    src/app/globals.css
    src/lib/supabase/server.ts
    src/lib/supabase/client.ts
    src/lib/utils.ts
    .env.example
    .env.local
    .gitignore
  </files>
  <action>
    1. Scaffold a new Next.js 15 project in the current directory using `npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*" --yes`. This creates the base project with App Router, TypeScript, Tailwind CSS, and src directory.

    2. Install Supabase dependencies: `npm install @supabase/supabase-js @supabase/ssr`. Install Supabase CLI as dev dependency: `npm install -D supabase`.

    3. Install utility dependencies for shadcn/ui compatibility: `npm install clsx tailwind-merge`.

    4. Create `src/lib/utils.ts` with the standard `cn()` utility function combining clsx and tailwind-merge (required by shadcn/ui components):
       ```typescript
       import { type ClassValue, clsx } from "clsx"
       import { twMerge } from "tailwind-merge"
       export function cn(...inputs: ClassValue[]) {
         return twMerge(clsx(inputs))
       }
       ```

    5. Create `src/lib/supabase/server.ts` following the official @supabase/ssr pattern for Server Components. The function must be `async` (because `cookies()` is async in Next.js 15), use `createServerClient` from `@supabase/ssr`, implement `getAll()` and `setAll()` cookie methods, and wrap `setAll` in try/catch for Server Component compatibility. Import `Database` type from `@/types/database.types` and pass as generic to createServerClient for type safety.

    6. Create `src/lib/supabase/client.ts` using `createBrowserClient` from `@supabase/ssr` for Client Components. This is a synchronous function. Import `Database` type and pass as generic.

    7. Create `.env.example` with these three variables and placeholder values:
       ```
       NEXT_PUBLIC_SUPABASE_URL=https://YOUR_PROJECT.supabase.co
       NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here
       SUPABASE_SERVICE_ROLE_KEY=your-service-role-key-here
       ```

    8. Create `.env.local` with the same three variables and empty values (user will fill in). Ensure `.env.local` is in `.gitignore` (create-next-app should handle this, but verify).

    9. Update `src/app/layout.tsx`: Set the HTML `lang` attribute to `"nl"` (Dutch), set metadata title to "NextWave Solutions - Feedback Platform", set metadata description to "Client email feedback platform" (in English for SEO, UI will be Dutch).

    10. Update `src/app/page.tsx` to a minimal placeholder: display "NextWave Solutions" heading and "Feedback Platform" subtitle, centered on page. Use Tailwind classes only (no custom components yet).

    IMPORTANT: Do NOT configure Tailwind theme colors in this task -- that will be done in Plan 02 with shadcn/ui initialization. Keep the default Tailwind config from create-next-app.
  </action>
  <verify>
    Run `npm run build` -- must complete without errors.
    Run `npm run dev` -- must start the development server.
    Verify files exist: `src/lib/supabase/server.ts`, `src/lib/supabase/client.ts`, `.env.example`.
    Verify `.env.local` is in `.gitignore`.
    Verify `package.json` contains `@supabase/supabase-js`, `@supabase/ssr`, `clsx`, `tailwind-merge`.
  </verify>
  <done>
    Next.js 15 app builds successfully. Supabase server and client utilities exist at `src/lib/supabase/server.ts` and `src/lib/supabase/client.ts`. Environment variables documented in `.env.example` with NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, and SUPABASE_SERVICE_ROLE_KEY. The `cn()` utility exists for class merging. Development server starts without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database migration SQL with schema, RLS policies, and TypeScript types</name>
  <files>
    supabase/migrations/20260210000000_create_initial_schema.sql
    src/types/database.types.ts
  </files>
  <action>
    1. Create directory `supabase/migrations/` if it does not exist.

    2. Create migration file `supabase/migrations/20260210000000_create_initial_schema.sql` with the complete database schema:

       **forms table (DB-01):**
       - `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - `client_name` TEXT NOT NULL
       - `slug` TEXT NOT NULL UNIQUE
       - `status` TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'completed'))
       - `webhook_url` TEXT (nullable)
       - `created_at` TIMESTAMPTZ NOT NULL DEFAULT NOW()
       - `updated_at` TIMESTAMPTZ NOT NULL DEFAULT NOW()

       Note: Use 'active' and 'completed' as status values (not 'active'/'archived' from research -- the actual app uses active/completed per requirements for tracking whether feedback has been submitted).

       **email_variants table (DB-02):**
       - `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - `form_id` UUID NOT NULL REFERENCES forms(id) ON DELETE CASCADE
       - `email_type` TEXT NOT NULL CHECK (email_type IN ('eerste_mail', 'opvolgmail_1', 'opvolgmail_2'))
       - `variant_number` INTEGER NOT NULL
       - `subject_line` TEXT NOT NULL
       - `email_body` TEXT NOT NULL
       - `sort_order` INTEGER NOT NULL DEFAULT 0
       - `created_at` TIMESTAMPTZ NOT NULL DEFAULT NOW()
       - UNIQUE(form_id, email_type, variant_number)

       Note: Use Dutch email_type values ('eerste_mail', 'opvolgmail_1', 'opvolgmail_2') matching the UI terminology from the roadmap.

       **feedback_responses table (DB-03):**
       - `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - `form_id` UUID NOT NULL REFERENCES forms(id) ON DELETE CASCADE
       - `variant_id` UUID NOT NULL REFERENCES email_variants(id) ON DELETE CASCADE
       - `feedback_text` TEXT NOT NULL
       - `submitted_at` TIMESTAMPTZ NOT NULL DEFAULT NOW()

       **Indexes for RLS performance:**
       - `CREATE INDEX idx_forms_slug ON forms(slug);`
       - `CREATE INDEX idx_email_variants_form_id ON email_variants(form_id);`
       - `CREATE INDEX idx_feedback_responses_form_id ON feedback_responses(form_id);`
       - `CREATE INDEX idx_feedback_responses_variant_id ON feedback_responses(variant_id);`

       **Enable RLS on all three tables (DB-04, DB-05, DB-06):**
       ```sql
       ALTER TABLE forms ENABLE ROW LEVEL SECURITY;
       ALTER TABLE email_variants ENABLE ROW LEVEL SECURITY;
       ALTER TABLE feedback_responses ENABLE ROW LEVEL SECURITY;
       ```

       **RLS Policies (DB-04) - Authenticated users full access:**
       ```sql
       CREATE POLICY "Authenticated full access on forms"
         ON forms FOR ALL TO authenticated
         USING (true) WITH CHECK (true);

       CREATE POLICY "Authenticated full access on email_variants"
         ON email_variants FOR ALL TO authenticated
         USING (true) WITH CHECK (true);

       CREATE POLICY "Authenticated full access on feedback_responses"
         ON feedback_responses FOR ALL TO authenticated
         USING (true) WITH CHECK (true);
       ```

       **RLS Policies (DB-05) - Anonymous SELECT on forms and email_variants:**
       ```sql
       CREATE POLICY "Anonymous can read forms"
         ON forms FOR SELECT TO anon
         USING (true);

       CREATE POLICY "Anonymous can read email_variants"
         ON email_variants FOR SELECT TO anon
         USING (true);
       ```

       **RLS Policy (DB-06) - Anonymous INSERT on feedback_responses:**
       ```sql
       CREATE POLICY "Anonymous can insert feedback"
         ON feedback_responses FOR INSERT TO anon
         WITH CHECK (true);
       ```

       **Updated_at trigger for forms:**
       Create a trigger function and trigger to automatically update `updated_at` on the forms table:
       ```sql
       CREATE OR REPLACE FUNCTION update_updated_at_column()
       RETURNS TRIGGER AS $$
       BEGIN
         NEW.updated_at = NOW();
         RETURN NEW;
       END;
       $$ language 'plpgsql';

       CREATE TRIGGER update_forms_updated_at
         BEFORE UPDATE ON forms
         FOR EACH ROW
         EXECUTE FUNCTION update_updated_at_column();
       ```

    3. Create `src/types/database.types.ts` with manually crafted TypeScript types that mirror the schema exactly. Since we cannot run `supabase gen types` without a running database, create the types manually:

       Define the `Database` interface with `public` schema containing `Tables` for `forms`, `email_variants`, and `feedback_responses`. Each table has `Row` (all columns), `Insert` (required + optional for inserts), and `Update` (all optional for updates) types.

       Also export convenience type aliases:
       ```typescript
       export type Form = Database['public']['Tables']['forms']['Row']
       export type FormInsert = Database['public']['Tables']['forms']['Insert']
       export type EmailVariant = Database['public']['Tables']['email_variants']['Row']
       export type EmailVariantInsert = Database['public']['Tables']['email_variants']['Insert']
       export type FeedbackResponse = Database['public']['Tables']['feedback_responses']['Row']
       export type FeedbackResponseInsert = Database['public']['Tables']['feedback_responses']['Insert']
       ```

       Ensure types match the exact column names and types from the migration SQL. UUID columns are `string`, TIMESTAMPTZ columns are `string`, TEXT columns are `string`, INTEGER columns are `number`. Status field should be typed as `'active' | 'completed'`. Email type field should be typed as `'eerste_mail' | 'opvolgmail_1' | 'opvolgmail_2'`.

    4. Verify the TypeScript types compile without errors by running `npx tsc --noEmit`.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- must pass without type errors.
    Verify migration file exists at `supabase/migrations/20260210000000_create_initial_schema.sql`.
    Verify migration SQL contains: CREATE TABLE for all 3 tables, ENABLE ROW LEVEL SECURITY for all 3, at least 7 CREATE POLICY statements, at least 4 CREATE INDEX statements, ON DELETE CASCADE on foreign keys.
    Verify `src/types/database.types.ts` exports Form, EmailVariant, FeedbackResponse types.
    Run `npm run build` -- full build must still pass.
  </verify>
  <done>
    Migration SQL file exists at `supabase/migrations/20260210000000_create_initial_schema.sql` with complete schema for forms (DB-01), email_variants (DB-02), and feedback_responses (DB-03) tables. RLS enabled on all tables with policies for authenticated full access (DB-04), anonymous SELECT on forms and email_variants (DB-05), and anonymous INSERT on feedback_responses (DB-06). Migration file exists in supabase/migrations/ (DB-07). Performance indexes on slug, form_id, and variant_id columns. TypeScript types mirror the schema exactly and compile without errors.
  </done>
</task>

</tasks>

<verification>
Phase 1 Plan 01 verification checklist:
1. `npm run build` passes -- application compiles
2. `npm run dev` starts development server
3. `src/lib/supabase/server.ts` exports async createClient using @supabase/ssr
4. `src/lib/supabase/client.ts` exports createClient using @supabase/ssr
5. `.env.example` contains all three Supabase environment variables
6. Migration SQL creates 3 tables, enables RLS, creates 7+ policies, creates 4+ indexes
7. TypeScript types in `src/types/database.types.ts` compile and match schema
8. `npx tsc --noEmit` passes
</verification>

<success_criteria>
- Next.js 15 app scaffolded and builds successfully
- Supabase server/client utilities created with proper @supabase/ssr patterns
- Database migration SQL is complete with schema, RLS, indexes, and triggers
- TypeScript database types are defined and importable
- Environment variables documented in .env.example
- All requirements DB-01 through DB-07 and INFRA-01 addressed
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-design-system/01-01-SUMMARY.md`
</output>
